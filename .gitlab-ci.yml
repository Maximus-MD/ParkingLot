stages:
  - build
  - test
  - analyze
  - artifact
  - packing
  - scanning
  - staging
  - production

variables:
  MAVEN_IMAGE: "maven:3.8.7-openjdk-18"
  MAVEN_CACHE_DIR: ".m2/repository"
  NEXUS_URL: "${Nexus_REPO_URL}"
  NEXUS_USER: "${Nexus_REPO_USER}"
  NEXUS_PASSWORD: "${Nexus_REPO_PASS}"
  SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
  SONAR_PROJECT_KEY: "${SONAR_PROJECT_KEY}"
  GIT_DEPTH: "0"
  ARTIFACT_ID: "parkinglot"
  GROUP_ID: "com.endava.md.internship"

cache:
  paths:
    - $MAVEN_CACHE_DIR

build:
  stage: build
  image: $MAVEN_IMAGE
  script:
    - echo "Building the project"
    - echo "JAVA_HOME is $JAVA_HOME"
    - ./mvnw -e -X $MAVEN_CLI_OPTS clean package
  artifacts:
    paths:
      - target/*.jar
    expire_in: 3 days

maven_test:
  stage: test
  image: $MAVEN_IMAGE
  script:
    - echo "Running tests"
    - ./mvnw clean -e -X $MAVEN_CLI_OPTS
    - ./mvnw -e -X $MAVEN_CLI_OPTS test
  dependencies:
    - build
  artifacts:
    paths:
      - target/surefire-reports
    reports:
      junit: target/surefire-reports/*.xml
    expire_in: 1 week

snyk_scan_jar:
  stage: analyze
  image: ${SNYK_IMAGE}
  script:
    - echo "Authenticating Snyk..."
    - snyk auth $SNYK_TOKEN
    - echo "Starting Snyk scan for Maven dependencies"
    - snyk test --file=pom.xml  # Snyk scans for vulnerabilities in dependencies listed in the pom.xml
    - snyk test target/*.jar  # Scan the JAR file directly
  dependencies:
    - build
  allow_failure: true

sonar_analyze:
  stage: analyze
  image: maven:3-eclipse-temurin-17
  variables:
    MAVEN_OPTS: "-Dsonar.host.url=${SONAR_HOST_URL} -Dsonar.token=${SONAR_TOKEN}"
  script:
    - ./mvnw $MAVEN_CLI_OPTS clean install -X
    - echo "Running SonarQube analysis"
    - ./mvnw verify sonar:sonar -Dsonar.qualitygate.wait=true
  dependencies:
    - build

deploy_nexus:
  stage: artifact
  image: curlimages/curl:8.11.0
  script:
    - echo "Parsing POM file..."
    - VERSION=$(grep "SNAPSHOT<\/version>" pom.xml | head -n 1 | sed 's/.*<version>\(.*\)<\/version>.*/\1/')
    - echo "Group ID $GROUP_ID"
    - echo "Artifact ID $ARTIFACT_ID"
    - echo "Version $VERSION"
    - echo "Deploying artifacts to Nexus"
    - |
      curl -v -u $NEXUS_USER:$NEXUS_PASSWORD \
      ${NEXUS_URL}/repository/maven-snapshots/${GROUP_ID//.//}/${ARTIFACT_ID}/${ARTIFACT_ID}-${VERSION}-${CI_COMMIT_SHORT_SHA}.jar \
      --upload-file target/${ARTIFACT_ID}-${VERSION}.jar
    - echo "VERSION=${VERSION}" >> build.env
  artifacts:
    reports:
      dotenv: build.env
  dependencies:
    - build
  only:
    - master

kaniko_build_and_push:
  stage: packing
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  only:
    - master
  script:
    - |
      if echo "$VERSION" | grep -iq "SNAPSHOT"; then
        export REPO_TYPE="snapshots"
      else
        export REPO_TYPE="releases"
      fi
    - export NEXUS_AUTH=$(echo -n "${Nexus_REPO_USER}:${Nexus_REPO_PASS}" | base64)
    - echo "{\"auths\":{\"$REPO_DOCKER_URL\":{\"auth\":\"$NEXUS_AUTH\"}}}" > /kaniko/.docker/config.json
    - env
    - |
      /kaniko/executor \
        --context $CI_PROJECT_DIR \
        --dockerfile $CI_PROJECT_DIR/docker/Dockerfile \
        --destination ${REPO_DOCKER_URL}/${ARTIFACT_ID}:${VERSION}-${CI_COMMIT_SHORT_SHA} \
        --destination ${REPO_DOCKER_URL}/${ARTIFACT_ID}:latest-${REPO_TYPE%?} \
        --insecure \
        --build-arg GROUP_ID=$GROUP_ID \
        --build-arg ARTIFACT_ID=$ARTIFACT_ID \
        --build-arg VERSION=$VERSION \
        --build-arg Nexus_REPO_USER=$Nexus_REPO_USER \
        --build-arg Nexus_REPO_PASS=$Nexus_REPO_PASS \
        --build-arg Nexus_REPO_URL=$Nexus_REPO_URL \
        --build-arg REPO_TYPE=$REPO_TYPE \
        --build-arg CI_COMMIT_SHORT_SHA=$CI_COMMIT_SHORT_SHA
        
trivy_image_scan_staging:
  stage: scanning
  image: aquasec/trivy:latest
  script:
    - echo "Scanning Docker image for vulnerabilities before staging deployment"
    - trivy image --no-progress --exit-code 1 ${REPO_DOCKER_URL}/${ARTIFACT_ID}:${VERSION}-${CI_COMMIT_SHORT_SHA}
  dependencies:
    - kaniko_build_and_push
  only:
    - master

deploy_staging:
  stage: staging
  image: alpine:3.20.3
  only:
    - master
  script:
    - apk add --no-cache yq git  # Install tools (yq to modify YAML, git to commit changes)
    - git clone https://oauth2:$CI_JOB_TOKEN@${FLUX_REPO}
    - cd fluxcd

    # Use yq to modify the HelmRelease manifest and update the image tag dynamically
    - yq eval ".spec.values.image.tag = \"${VERSION}-${CI_COMMIT_SHORT_SHA}\"" -i clusters/endava-eks/parkinglot/staging/helmRelease.yaml
    
    # Optionally, you can also update other values, such as the repository tag or version.
    # e.g., yq eval ".spec.chart.spec.version = \"${CI_COMMIT_REF_NAME}\"" -i parkinglot-api/HelmRelease.yaml

    # Commit the changes
    - git config --global user.email "gitlab@endava.com"
    - git config --global user.name "GitLab CI"
    - git add clusters/endava-eks/parkinglot/staging/helmRelease.yaml
    - git commit -m "Update HelmRelease for new image version ${VERSION}-${CI_COMMIT_SHORT_SHA}"
    - git push origin main  # Push the changes to the Git repository
  environment:
    name: staging

dast_scan_staging:
  stage: staging
  image: owasp/zap2docker-stable:latest
  script:
    - echo "Starting DAST scan on deployed staging app"
    - kubectl run zap-scanner --rm -i --tty --image=owasp/zap2docker-stable:latest --restart=Never -- \
        zap-baseline.py -t https://api-stg.parking.mddinternship.com/ -r /zap/wrk/dast-report.html
    - echo "DAST scan completed. Report generated as dast-report.html"
  dependencies:
    - deploy_staging
  artifacts:
    paths:
      - dast-report.html
  only:
    - master

deploy_production:
  stage: production
  image: alpine:3.20.3
  only:
    - master
  script:
    - apk add --no-cache yq git  # Install tools (yq to modify YAML, git to commit changes)
    - git clone https://oauth2:$CI_JOB_TOKEN@${FLUX_REPO}
    - cd fluxcd

    # Use yq to modify the HelmRelease manifest and update the image tag dynamically
    - yq eval ".spec.values.image.tag = \"${VERSION}-${CI_COMMIT_SHORT_SHA}\"" -i clusters/endava-eks/parkinglot/production/helmRelease.yaml
    
    # Optionally, you can also update other values, such as the repository tag or version.
    # e.g., yq eval ".spec.chart.spec.version = \"${CI_COMMIT_REF_NAME}\"" -i parkinglot-api/HelmRelease.yaml

    # Commit the changes
    - git config --global user.email "gitlab@endava.com"
    - git config --global user.name "GitLab CI"
    - git add clusters/endava-eks/parkinglot/production/helmRelease.yaml
    - git commit -m "Update HelmRelease for new image version ${VERSION}-${CI_COMMIT_SHORT_SHA}"
    - git push origin main  # Push the changes to the Git repository
  when: manual
  environment:
    name: production